---
description: 设计模式入门
---

# 第一章 策略模式

### 设计一个模拟鸭子游戏

游戏中会出现各种鸭子，游泳戏水的，乱叫的。

为了复用呱呱叫和游泳的方法，使用继承

![&#x4F7F;&#x7528;&#x7EE7;&#x627F;&#x8FBE;&#x5230;&#x4EE3;&#x7801;&#x590D;&#x7528;](.gitbook/assets/image%20%285%29.png)

现在来了新需求，给鸭子加上飞的功能。

![&#x7ED9;&#x7236;&#x7C7B;&#x52A0;&#x4E0A;fly&#x65B9;&#x6CD5;](.gitbook/assets/image%20%2813%29.png)

### **问题来了，某些鸭子不该拥有这个fly方法**

为了修复这个问题我们需要给不需要fly的覆盖掉。

这个时候就体会到了 **为了“复用”使用继承时会带来一些头痛的问题**

### 使用接口来改善设计会如何？

会飞的鸭子就实现Flable接口，会叫的就实现Quackable接口

![](.gitbook/assets/image%20%289%29.png)

其实也是相当崩溃的，这几乎没有实现代码复用。

### 这里引入一些设计原则

* 找出应用中变化的部分，然后封装起来，避免和不变的代码混杂在一起
* 针对接口编程，不要针对实现编程（接口指的是超类型在java中可以是“抽象类”或者”接口”）
* 多用组合，少用继承

### 使用这两个设计原则来改善我们的设计

我们先将变化的部分抽取出来。

![](.gitbook/assets/image%20%282%29.png)

飞行功能可能会变化很大，我们可以根据变化来给它多个实现。

![](.gitbook/assets/image%20%2814%29.png)

**在鸭子类中组合飞行和呱呱叫行为**

![&#x7EC4;&#x5408;&#x884C;&#x4E3A;&#x7684;&#x9E2D;&#x5B50;&#x7C7B;](.gitbook/assets/image%20%287%29.png)

![&#x6700;&#x7EC8;&#x8BBE;&#x8BA1;&#x5B8C;&#x6210;&#x540E;&#x7684;&#x9E2D;&#x5B50;&#x7C7B;](.gitbook/assets/image%20%2810%29.png)

**这样的设计，可以让飞行或者呱呱叫的方法被其他对象复用，即使新增了一些行为，也不会影响到已经使用飞行行为的鸭子类**

### 策略模式

**定义了算法族分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户**

\*\*\*\*



